# This is a modified version of the plotGMPhyloMorphoSpace function from 'geomorph'
#
# Changes include:
### Ability to flip axes (written by Dr Randi H Griffin https://github.com/rgriff23)
#
### Ability to specify colors for each branch, e.g. to take in a vector of colors generated by Phytool's plotBranchbyTrait
#
### Ability to pass more plotting parameters such as labels and point colors
#
#' Plot phylogenetic tree and specimens in tangent space
#'
#' Function plots a phylogenetic tree and a set of Procrustes-aligned specimens in tangent space
#'
#' The function creates a plot of the principal dimensions of tangent space for a set of Procrustes-aligned 
#'   specimens. Default is a plot of PC axis 1 and 2. The phylogenetic tree for these specimens is superimposed in this plot revealing how shape 
#'   evolves (e.g., Rohlf 2002; Klingenberg and Gidaszewski 2010). The plot also displays the ancestral 
#'   states for each node of the phylogenetic tree (analogous to from \code{\link[phytools]{fastAnc}} from phytools), whose values can optionally be returned. 
#'   If a tree with branch lengths scaled by time is used, with the option zaxis = "time", the function plots a 3D phylomorphospace, with internal nodes positioned along the Z-axis scaled 
#'   to time (a.k.a. Chronophylomorphospace, Sakamoto & Ruta 2012).
#'
#' @param phy A phylogenetic tree of {class phylo} - see \code{\link[ape]{read.tree}} in library ape
#' @param A A matrix (n x [p x k]) or 3D array (p x k x n) containing GPA-aligned coordinates for a set of specimens
#' @param tip.labels A logical value indicating whether taxa labels (tips) should be included
#' @param node.labels A logical value indicating whether node labels (ancestors) should be included
#' @param xaxis A numeric value indicating which PC axis should be displayed as the X-axis (default = PC1)
#' @param yaxis A numeric value indicating which PC axis should be displayed as the Y-axis (default = PC2)
#' @param zaxis Optional, a numeric value indicating which PC axis should be displayed as the Z-axis (e.g. PC3) or if zaxis="time", 
#' internal nodes are plotted along the Z-axis relative to time
#' @param ancStates Either a logical value indicating whether ancestral state values should be returned, or a matrix of ancestral states (i.e. calculated with \code{\link[phytools]{fastAnc}} or \code{\link[ape]{ace}})
#' @param plot.param A list of plotting parameters for the tips (t.bg, t.pch, t.cex), nodes (n.bg, n.pch, n.cex), 
#' branches (l.col, lwd), taxa labels (txt.cex, txt.adj, txt.col) and node labels (n.txt.cex, n.txt.adj, n.txt.col)
#' @param shadow A logical value indicating whether a 2D phylomorphospace should be plotted at the base when zaxis="time"
#' @export
#' @keywords visualization
#' @author Dean Adams & Emma Sherratt
#' @return Function returns estimated ancestral states if {ancStates=TRUE}
#' @references Klingenberg, C. P., and N. A. Gidaszewski. 2010. Testing and quantifying phylogenetic 
#'   signals and homoplasy in morphometric data. Syst. Biol. 59:245-261.
#' @references Rohlf, F. J. 2002. Geometric morphometrics and phylogeny. Pp.175-193 in N. Macleod, and
#'   P. Forey, eds. Morphology, shape, and phylogeny. Taylor & Francis, London.
#' @references Sakamoto, M. and Ruta, M. 2012. Convergence and Divergence in the Evolution of Cat
#' Skulls: Temporal and Spatial Patterns of Morphological Diversity. PLoSONE 7(7): e39752.
#' @examples
#' data(plethspecies) 
#' Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment    
#'
#' plotGMPhyloMorphoSpace(plethspecies$phy,Y.gpa$coords)
#' plotGMPhyloMorphoSpace(plethspecies$phy,Y.gpa$coords, 
#'                  plot.param=list(t.bg="blue",txt.col="red",n.cex=1))
#' #NOTE: 3D plot also available: plotGMPhyloMorphoSpace(plethspecies$phy,Y.gpa$coords, zaxis= "time",
#' #                 plot.param=list(n.cex=2, n.bg="blue"), shadow=TRUE)
#' 
#' 
#' NOTE FROM RANDI GRIFFIN: lines 87-88 were added to allow flipping x and y axes by specifying negative numbers
#' The rest of the function is identical to https://github.com/geomorphR/geomorph/blob/Stable/R/plotGMPhyloMorphoSpace.r
#' downloaded on August 5, 2017
#' 
plotGMPhyloMorphoSpace_plotmod<-function(phy,A,tip.labels=TRUE,tip.text=NULL,node.labels=TRUE,ancStates=TRUE, xaxis=1, yaxis=2, zaxis=NULL, plot.param = list(), shadow=FALSE){
        if(any(is.na(A))==T){
                stop("Data matrix contains missing values. Estimate these first (see 'estimate.missing').")  }
        if (length(dim(A))==3){ 
                if(is.null(dimnames(A)[[3]])){
                        stop("Data matrix does not include taxa names as dimnames for 3rd dimension.")  }
                x<-two.d.array(A)}
        if (length(dim(A))==2){ 
                if(is.null(dimnames(A)[[1]])){
                        stop("Data matrix does not include taxa names as dimnames for rows.")  }
                x<-A }
        if (!inherits(phy, "phylo"))
                stop("tree must be of class 'phylo.'")
        if (!is.binary.tree(phy)) 
                stop("tree is not fully bifurcating (consider 'multi2di' in ape.")
        N<-length(phy$tip.label)
        Nnode <- phy$Nnode
        if(N!=dim(x)[1]){
                stop("Number of taxa in data matrix and tree are not not equal.")  }
        if(length(match(rownames(x), phy$tip.label))!=N) 
                stop("Data matrix missing some taxa present on the tree.")
        if(length(match(phy$tip.label,rownames(x)))!=N) 
                stop("Tree missing some taxa in the data matrix.")
        x<-x[phy$tip.label, ]  
        anc.states<-NULL   #follows fastAnc in phytools
        for (i in 1:ncol(x)){
                x1<-x[,i]
                tmp <- vector()
                for (j in 1:Nnode + N) {
                        a <- multi2di(root(phy, node = j))
                        tmp[j - N] <- ace(x1, a, method = "pic")$ace[1]
                }
                anc.states<-cbind(anc.states,tmp)   }
        colnames(anc.states)<-NULL
        row.names(anc.states)<-1:length(tmp)
        all.data<-rbind(x,anc.states)  
        pcdata<-prcomp(all.data)$x 
        pcdata<-pcdata-matrix(rep(pcdata[(N+1),],nrow(pcdata)), nrow=nrow(pcdata),byrow=T)  #phylogenetic mean adjustment
        if (xaxis < 1) {xaxis <- -1*xaxis; pcdata[,xaxis] <- -1*pcdata[,xaxis]} # flip x axis
        if (yaxis < 1) {yaxis <- -1*yaxis; pcdata[,yaxis] <- -1*pcdata[,yaxis]} # flip y axis
        #plotting  
        p.p <- plot.param
        if(is.null(p.p$t.bg)) p.p$t.bg="black" ; if(is.null(p.p$t.pch)) p.p$t.pch=21
        if(is.null(p.p$t.cex)) p.p$t.cex=2 ; if(is.null(p.p$n.bg)) p.p$n.bg="white"
        if(is.null(p.p$n.pch)) p.p$n.pch=21 ; if(is.null(p.p$n.cex)) p.p$n.cex=1.25
        if(is.null(p.p$l.col)) p.p$l.col="black" ; if(is.null(p.p$lwd)) p.p$lwd=3
        if(is.null(p.p$txt.adj)) p.p$txt.adj=c(-.1,-.1) ; if(is.null(p.p$txt.col)) p.p$txt.col="black"
        if(is.null(p.p$txt.cex)) p.p$txt.cex=1 ; if(is.null(p.p$n.txt.adj)) p.p$n.txt.adj=c(-.1,-.1) 
        if(is.null(p.p$n.txt.col)) p.p$n.txt.col="black" ; if(is.null(p.p$n.txt.cex)) p.p$n.txt.cex=0.6
        if(is.null(p.p$xlim)) p.p$xlim = limits(pcdata[,xaxis],1.5); if(is.null(p.p$ylim)) p.p$ylim = limits(pcdata[,yaxis],1.5)
        limits = function(x,s){ 
                r = range(x)
                rc=scale(r,scale=F)
                l=mean(r)+s*rc}
        # regular 2D phylomorphospace
        if(is.null(zaxis)){
                if(tip.labels==TRUE){
                        plot(pcdata[,xaxis],pcdata[,yaxis],type="n",xlim = p.p$xlim, ylim = p.p$ylim, asp=1,
                             xlab = p.p$xlab, ylab = p.p$ylab) }
                if(tip.labels==FALSE) {
                        plot(pcdata[,xaxis],pcdata[,yaxis],type="n", main = p.p$main, xlab = p.p$xlab, ylab = p.p$ylab, xlim = p.p$xlim, ylim = p.p$ylim) }
                for (i in 1:nrow(phy$edge)){
                        lines(pcdata[(phy$edge[i,]),xaxis],pcdata[(phy$edge[i,]),yaxis],type="l",col=p.p$l.col,lwd=p.p$lwd)
                }
                points(pcdata[(N+1):nrow(pcdata),xaxis], pcdata[(N+1):nrow(pcdata),yaxis],col="grey", pch=p.p$n.pch, bg=p.p$n.bg, cex=p.p$n.cex)
                points(pcdata[1:N,xaxis], pcdata[1:N,yaxis],col=p.p$t.bg,pch=p.p$t.pch, bg=p.p$t.bg, cex=p.p$t.cex)
                if(tip.labels==TRUE){
                        if(is.null(tip.text)) tip.text <- rownames(pcdata)[1:N]
                        text(pcdata[1:N,xaxis],pcdata[1:N,yaxis],tip.text,
                             col=p.p$txt.col,cex=p.p$txt.cex,adj=p.p$txt.adj)}
                if(node.labels==TRUE){
                        text(pcdata[(N + 1):nrow(pcdata),xaxis],pcdata[(N + 1):nrow(pcdata),yaxis],rownames(pcdata)[(N + 1):nrow(pcdata)],
                             col=p.p$n.txt.col,cex=p.p$n.txt.cex,adj=p.p$n.txt.adj)}
        }
        if(ancStates==TRUE){ return(anc.states)  }
}